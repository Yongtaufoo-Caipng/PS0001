def apply_move(board, turn, index, push_from):
   
    n = int(len(board) ** 0.5)  # len(board) gives total no. of cells(25), ** 0.5 takes the square root(5), int() converts it to an integer 
    new_board = board[:]
    new_board = list(board) # can modify new_board w/o changing original board
    
    row = index // n   # // is floor division get the integer only
    col = index % n
    
    if push_from == 'T':
        # shift column down from the top
        for r in range(row, 0, -1): # the loop counts downwards to prevent overwriting a value we still need to read
            new_board[r*n + col] = new_board[(r-1)*n + col] # destination index is r*n + col the cell at row r column col, source index is (r-1)*n + col the cell one row above the destination
            # destination index is r*n + col the cell at row r column col, source index is (r-1)*n + col the cell one row above the destination
            # 2D index formula r*n + c
            # definition of a downward shift for a 'T' push: destination (r, c) gets the value from one row above (r-1,c)
        new_board[col] = turn  # your piece (turn) is inserted at the top
    
    elif push_from == 'B':
        # shift column up from the bottom
        for r in range(row, n-1): # gives row, row+1, ..., n-2, loop goes upwards
            new_board[r*n + col] = new_board[(r+1)*n + col]
        new_board[(n-1)*n + col] = turn  # your piece is inserted at the bottom position
    
    elif push_from == 'L':
        # shift row right from the left, cells are shifted to the right
        for c in range(col, 0, -1): # loop counts right to left
            new_board[row*n + c] = new_board[row*n + (c-1)] # destination (row, c) gets the value from its left (row, c-1), right to left avoids overwriting data
        new_board[row*n] = turn  # your piece is inserted at the left position
    
    elif push_from == 'R':
        # shift row left from the right
        for c in range(col, n-1): # destination takes value from its right
            new_board[row*n + c] = new_board[row*n + (c+1)]
        new_board[row*n + (n-1)] = turn  # your piece is inserted at the right position
    
    return new_board

def play_game(board, player1_type, player2_type, player1_level, player2_level):
    #main game loop, defines a function named play_game that will run the whole match loop.
    #difficulty no. for the comp
    current_player = 1 #sets who moves first
    game_over = False #when False, game is still running. It is set to True when someone wins or quits which stops the loops.
    
    while not game_over:
        display_board(board)
        #start a while loop that keeps running until the game is over
        #not game_over is True when the game is still running
        #call a function to print the current board so that the plaer can see it before making a move
        
        if current_player == 1: #branch based on whose turn it is
            player_type = player1_type
            level = player1_level #difficulty for computer can be ignored if p1 is human
        else:
            player_type = player2_type
            level = player2_level
        
        print(f"Player {current_player}'s turn ({'X' if current_player == 1 else 'O'})")
        #prints whose turn it is
        #{'X' if current player == 1 else 'O'} is a conditional expression that choose 'X' for p1, 'O' for p2
        
        if player_type == "human": #checks if the current player is human
            index, push_from = get_human_move(board, current_player) #calls helper to validate input
        else: 
            print("Computer is thinking...") #print status message
            index, push_from = computer_move(board, current_player, level)
            print(f"Computer plays: index {index}, push from {push_from}")
