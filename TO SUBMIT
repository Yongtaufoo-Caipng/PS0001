import random
import math

# ---------------- CHECK MOVE ----------------
def check_move(board, turn, index, push_from): #passed into the function as a parameter
    
    n = int(len(board) ** 0.5)  # len(board) gives the total number of elements in the list
    #len(board)= n x n hence n = sqaureroot (len(board))
    #n is how many cubes fit on one side of the square board
    
    # Check if the cube index is within the range 0 to n^2-1
    # index is which cube the player pick, is a number
    if index < 0 or index >= len(board):
        return False
    #if either one of the index is true the whole thing will return false 
    
    # Check if the cube is on the outer ring of the board
    row = index // n   # // is floor division get the integer only and to get the row number 
    col = index % n  # is to check for col number 
    if not (row == 0 or row == n-1 or col == 0 or col == n-1):
            #top edge   #bottom edge  #left edge  #right edge
        return False
    
    # Check if the cube belongs to the player or is blank
    #!= not equal to, board[index] is the symbol at that point, means only X or O
    if board[index] != 0 and board[index] != turn: #turn is 1 or 2 
        return False #invalid move 
    
    # Check if push direction is valid
    if push_from not in ['T', 'B', 'L', 'R']:
        return False
    
    # Check if we're not pushing from the same position
    if (push_from == 'T' and row == 0) or \
       (push_from == 'B' and row == n-1) or \
       (push_from == 'L' and col == 0) or \
       (push_from == 'R' and col == n-1):
        return False 
    #to check if we are trying to push from the same edge that we are already on 
    #eg at 0 cannot push from Top position anymore, so if any of this is true can return false  
    
    return True


# ---------------- APPLY MOVE ----------------
def apply_move(board, turn, index, push_from):
   
    n = int(len(board) ** 0.5)  # len(board) gives total no. of cells(25), ** 0.5 takes the square root(5), int() converts it to an integer 
    new_board = board[:]  # create a copy so original isn't changed
    
    row = index // n   # // is floor division get the integer only
    col = index % n
    
    if push_from == 'T':
        # shift column down from the top
        for r in range(row, 0, -1): # the loop counts downwards to prevent overwriting a value we still need to read
            new_board[r*n + col] = new_board[(r-1)*n + col] # destination index is r*n + col the cell at row r column col, source index is (r-1)*n + col the cell one row above the destination
        new_board[col] = turn  # your piece (turn) is inserted at the top
    
    elif push_from == 'B':
        # shift column up from the bottom
        for r in range(row, n-1): # gives row, row+1, ..., n-2, loop goes upwards
            new_board[r*n + col] = new_board[(r+1)*n + col]
        new_board[(n-1)*n + col] = turn  # your piece is inserted at the bottom position
    
    elif push_from == 'L':
        # shift row right from the left, cells are shifted to the right
        for c in range(col, 0, -1): # loop counts right to left
            new_board[row*n + c] = new_board[row*n + (c-1)] # destination (row, c) gets the value from its left (row, c-1), right to left avoids overwriting data
        new_board[row*n] = turn  # your piece is inserted at the left position
    
    elif push_from == 'R':
        # shift row left from the right
        for c in range(col, n-1): # destination takes value from its right
            new_board[row*n + c] = new_board[row*n + (c+1)]
        new_board[row*n + (n-1)] = turn  # your piece is inserted at the right position
    
    return new_board


# ---------------- CHECK VICTORY ----------------
def check_victory(board, who_played):
    n = int(len(board) ** 0.5)
    player1_win = False
    player2_win = False
    #start with both false as none have won
    
    #check rows
    for i in range(n): #check each row 
        row_win1 = True 
        row_win2 = True
        for j in range(n):
            if board[i*n + j] != 1:
                row_win1 = False
            if board[i*n + j] != 2:
                row_win2 = False
        if row_win1:
            player1_win = True
        if row_win2:
            player2_win = True
    
    #check columns
    for j in range(n):
        col_win1 = True
        col_win2 = True
        for i in range(n):
            if board[i*n + j] != 1:
                col_win1 = False
            if board[i*n + j] != 2:
                col_win2 = False
        if col_win1:
            player1_win = True
        if col_win2:
            player2_win = True
    
    #check diagonal (top left to bottom right)
    diag1_win1 = True
    diag1_win2 = True
    for i in range(n):
        if board[i*n + i] != 1:
            diag1_win1 = False
        if board[i*n + i] != 2:
            diag1_win2 = False
    if diag1_win1:
        player1_win = True
    if diag1_win2:
        player2_win = True
    
    #check diagonal (top right to bottom left)
    diag2_win1 = True
    diag2_win2 = True
    for i in range(n):
        if board[i*n + (n-1-i)] != 1:
            diag2_win1 = False
        if board[i*n + (n-1-i)] != 2:
            diag2_win2 = False
    if diag2_win1:
        player1_win = True
    if diag2_win2:
        player2_win = True
    
    #determine winner
    if player1_win and player2_win:
        return 3 - who_played
    elif player1_win:
        return 1
    elif player2_win:
        return 2
    else:
        return 0


# ---------------- COMPUTER MOVE ----------------
def computer_move(board, turn, level):
    n = int(len(board) ** 0.5)
    valid_moves = []  # list of all possible valid moves
   
    # Generate all possible valid moves
    for index in range(len(board)):
        for push_from in ['T', 'B', 'L', 'R']:
            if check_move(board, turn, index, push_from):
                valid_moves.append((index, push_from))
    
    if not valid_moves:
        return (0, 'T')

    if level == 1:
        # Level 1: Random move
        return random.choice(valid_moves)
    
    elif level == 2:
        # Level 2: Try to win or block
        for index, push_from in valid_moves:
            test_board = apply_move(board, turn, index, push_from)
            if check_victory(test_board, turn) == turn:
                return index, push_from
        
        opponent = 3 - turn
        for index, push_from in valid_moves:
            test_board = apply_move(board, turn, index, push_from)
            for opp_index, opp_push in generate_valid_moves(test_board, opponent):
                opp_test_board = apply_move(test_board, opponent, opp_index, opp_push)
                if check_victory(opp_test_board, opponent) == opponent:
                    break
            else:
                return index, push_from
        
        return random.choice(valid_moves)


# ---------------- GENERATE VALID MOVES ----------------
def generate_valid_moves(board, turn):
    n = int(len(board) ** 0.5)
    valid_moves = []
    for index in range(len(board)):
        for push_from in ['T', 'B', 'L', 'R']:
            if check_move(board, turn, index, push_from):
                valid_moves.append((index, push_from))
    return valid_moves


# ---------------- DISPLAY BOARD ----------------
def display_board(board):
    n = int(len(board) ** 0.5)  # get side length
    print("=" * (n * 4 + 1))      # Each cell takes up 4 characters
    
    for i in range(n):
        row_str = "|"      
        for j in range(n):         
            symbol = " "           
            if board[i*n + j] == 1:
                symbol = "X"       
            elif board[i*n + j] == 2:
                symbol = "O"       
            row_str += f" {symbol} |"
        print(row_str)
        if i < n - 1:              
            print("|" + "---|" * n)
    
    print("=" * (n * 4 + 1))   
    
    print("\nIndex positions:")
    for i in range(n):
        row_str = ""
        for j in range(n):
            row_str += f" {i*n + j:2d} "   
        print(row_str)
    print()


# ---------------- MENU ----------------
def menu():
    print("Welcome to Quixo!")
    print("=" * 50)

    n = 5
    board = [0] * (n * n)
    turn = 1
    winner = 0

    while winner == 0:
        display_board(board)
        print(f"Player {turn}'s turn:")
        if turn == 1:
            index = int(input("Enter cube index (0â€“24): "))
            push_from = input("Enter direction (T, B, L, R): ").upper()
            if check_move(board, turn, index, push_from):
                board = apply_move(board, turn, index, push_from)
            else:
                print("Invalid move! Try again.")
                continue
        else:
            print("Computer is thinking...")
            index, push_from = computer_move(board, turn, 1)
            print(f"Computer chose index {index} from {push_from}")
            board = apply_move(board, turn, index, push_from)
        
        winner = check_victory(board, turn)
        if winner == 0:
            turn = 2 if turn == 1 else 1

    display_board(board)
    print(f"\nPlayer {winner} wins!")


# ---------------- MAIN ----------------
if __name__ == "__main__":
    menu()
