# %%
import random
import math

# ---------------- CHECK MOVE ----------------
def check_move(board, turn, index, push_from): #passed into the function as a parameter
    
    n = int(len(board) ** 0.5)  # len(board) gives the total number of elements in the list
    #len(board)= n x n hence n = sqaureroot (len(board))
    #n is how many cubes fit on one side of the square board
    
    # Check if the cube index is within the range 0 to n^2-1
    # index is which cube the player pick, is a number
    if index < 0 or index >= len(board):
        return False
    #if either one of the index is true the whole thing will return false 
    
    # Check if the cube is on the outer ring of the board
    row = index // n   # // is floor division get the integer only and to get the row number 
    col = index % n  # is to check for col number 
    if not (row == 0 or row == n-1 or col == 0 or col == n-1):
            #top edge   #bottom edge  #left edge  #right edge
        return False
    
    # Check if the cube belongs to the player or is blank
    #!= not equal to, board[index] is the symbol at that point, means only X or O
    if board[index] != 0 and board[index] != turn: #turn is 1 or 2 
        return False #invalid move 
    
    # Check if push direction is valid
    if push_from not in ['T', 'B', 'L', 'R']:
        return False
    
    # Check if we're not pushing from the same position
    if (push_from == 'T' and row == 0) or \
       (push_from == 'B' and row == n-1) or \
       (push_from == 'L' and col == 0) or \
       (push_from == 'R' and col == n-1):
        return False 
    #to check if we are trying to push from the same edge that we are already on 
    #eg at 0 cannot push from Top position anymore, so if any of this is true can return false  
    
    return True


# ---------------- APPLY MOVE ----------------
def apply_move(board, turn, index, push_from):
   
    n = int(len(board) ** 0.5)  # len(board) gives total no. of cells(25), ** 0.5 takes the square root(5), int() converts it to an integer 
    new_board = board[:]  # create a copy so original isn't changed
    
    row = index // n   # // is floor division get the integer only
    col = index % n
    
    if push_from == 'T':
        # shift column down from the top
        for r in range(row, 0, -1): # the loop counts downwards to prevent overwriting a value we still need to read
            new_board[r*n + col] = new_board[(r-1)*n + col] # destination index is r*n + col the cell at row r column col, source index is (r-1)*n + col the cell one row above the destination
        new_board[col] = turn  # your piece (turn) is inserted at the top
    
    elif push_from == 'B':
        # shift column up from the bottom
        for r in range(row, n-1): # gives row, row+1, ..., n-2, loop goes upwards
            new_board[r*n + col] = new_board[(r+1)*n + col]
        new_board[(n-1)*n + col] = turn  # your piece is inserted at the bottom position
    
    elif push_from == 'L':
        # shift row right from the left, cells are shifted to the right
        for c in range(col, 0, -1): # loop counts right to left
            new_board[row*n + c] = new_board[row*n + (c-1)] # destination (row, c) gets the value from its left (row, c-1), right to left avoids overwriting data
        new_board[row*n] = turn  # your piece is inserted at the left position
    
    elif push_from == 'R':
        # shift row left from the right
        for c in range(col, n-1): # destination takes value from its right
            new_board[row*n + c] = new_board[row*n + (c+1)]
        new_board[row*n + (n-1)] = turn  # your piece is inserted at the right position
    
    return new_board


# ---------------- CHECK VICTORY ----------------
def check_victory(board, who_played):
    n = int(len(board) ** 0.5)
    player1_win = False
    player2_win = False
    #start with both false as none have won
    #start with false if not if the bottom checking part have error, players will win without actually winning
    #check rows
    for i in range(n): #check each row 
        row_win1 = True 
        row_win2 = True
        #asumming both player might win at this row
        for j in range(n):
            if board[i*n + j] != 1:
            #for this row (i) and at this column (j) does it have 1 or 2 
            #check at which specific square have either 1 or 2
            #if at that i row does not have all 1 then player 1 did not win
                row_win1 = False
            #repeat the same for player 2
            if board[i*n + j] != 2:
                row_win2 = False
        #if the whole row have 1 then player 1 wins, same for player 2
        if row_win1:
            player1_win = True
        if row_win2:
            player2_win = True
        #loop will continue for all rows
    
    #check columns
    #do the same for columns
    for j in range(n):
        col_win1 = True
        col_win2 = True
        for i in range(n):
            if board[i*n + j] != 1:
                col_win1 = False
            if board[i*n + j] != 2:
                col_win2 = False
        
        if col_win1:
            player1_win = True
        if col_win2:
            player2_win = True
        #loop continues for all column 
    #check diagonal (top right to bottom left)
    #do the same for second diagonal
    diag2_win1 = True
    diag2_win2 = True
    for i in range(n):
        if board[i*n + (n-1-i)] != 1:
        #checking for squares at 4,8,12,16,20 so use [i*n +(n-1-i)]
            diag2_win1 = False
        if board[i*n + (n-1-i)] != 2:
            diag2_win2 = False
    
    if diag2_win1:
        player1_win = True
    if diag2_win2:
        player2_win = True
    
    #determine winner
    if player1_win and player2_win:
        return 3 - who_played
    # - who played so if player 1 played then 3-1 so player 2 wins
    elif player1_win:
        return 1
    #return 1 = player 1 win
    elif player2_win:
        return 2
    #return 2 = player 2 win
    else:
        return 0
    # return 0 = no winners 


# ---------------- COMPUTER MOVE ----------------
def computer_move(board, turn, level):
    n = int(len(board) ** 0.5)
    valid_moves = []  # list of all possible valid moves
   
    # Generate all possible valid moves
    for index in range(len(board)):
        for push_from in ['T', 'B', 'L', 'R']:
            if check_move(board, turn, index, push_from):
                valid_moves.append((index, push_from))
    
    if not valid_moves:
        return (0, 'T')

    if level == 1:
        # Level 1: Random move
        return random.choice(valid_moves)
    
    elif level == 2:
        # Level 2: Try to win or block
        for index, push_from in valid_moves:
            test_board = apply_move(board, turn, index, push_from)
            if check_victory(test_board, turn) == turn:
                return index, push_from
        
        opponent = 3 - turn
        for index, push_from in valid_moves:
            test_board = apply_move(board, turn, index, push_from)
            for opp_index, opp_push in generate_valid_moves(test_board, opponent):
                opp_test_board = apply_move(test_board, opponent, opp_index, opp_push)
                if check_victory(opp_test_board, opponent) == opponent:
                    break
            else:
                return index, push_from
        
        return random.choice(valid_moves)


# ---------------- GENERATE VALID MOVES ----------------
def generate_valid_moves(board, turn):
    n = int(len(board) ** 0.5)
    valid_moves = []
    for index in range(len(board)):
        for push_from in ['T', 'B', 'L', 'R']:
            if check_move(board, turn, index, push_from):
                valid_moves.append((index, push_from))
    return valid_moves


# ---------------- DISPLAY BOARD ----------------
def display_board(board):
    n = int(len(board) ** 0.5)  # get side length
    print("=" * (n * 4 + 1))      # Each cell takes up 4 characters
    
    for i in range(n):
        row_str = "|"      
        for j in range(n):         
            symbol = " "           
            if board[i*n + j] == 1:
                symbol = "X"       
            elif board[i*n + j] == 2:
                symbol = "O"       
            row_str += f" {symbol} |"
        print(row_str)
        if i < n - 1:              
            print("|" + "---|" * n)
    
    print("=" * (n * 4 + 1))   
    
    print("\nIndex positions:")
    for i in range(n):
        row_str = ""
        for j in range(n):
            row_str += f" {i*n + j:2d} "   
        print(row_str)
    print()

# ---------------- GET_PLAYER_TYPE ----------------
def get_player_type(player_name):
    """Get player type (human or computer)."""
    #keep asking until we have a answer we want
    while True:
        #ask for player or human and store answer as a variable called choice
        choice = input(player_name + " type (1 for Human, 2 for Computer): ")
        #if entered 1 then is human, entered 2 is computer 
        if choice == "1":
            return "human"
        elif choice == "2":
            return "computer"
        #if player key something else go back and say enter 1 or 2 
        else:
            print("Please enter 1 or 2.")

# ---------------- GET_COMPUTER LEVEL ----------------
def get_computer_level(player_name):
    """Get computer difficulty level."""
    #keep asking until we have a answer we want
    while True:
        #ask player for computer level and store answer as a variable called level_input
        level_input = input(player_name + " computer level (1 for Easy, 2 for Medium): ")
        #if keyed 1 then easy if keyed 2 then medium
        if level_input == "1":
            return 1
        elif level_input == "2":
            return 2
        #if player key something else go back and say enter 1 or 2 
        else:
            print("Please enter 1 or 2.")

# ---------------- MENU ----------------
def menu():
    """
    Main menu function to handle game setup and flow.
    """
    print("Welcome to Quixo!")
    print("=" * 50)
    
    # Get board size
    while True:
        try:
            n = int(input("Enter board size (default 5): ") or 5)
            if n < 3:
                print("Board size must be at least 3.")
                continue
            break
        except ValueError:
            print("Please enter a valid number.")
    
    # Initialize board
    board = [0] * (n * n)
    
    # Get player types
    print("\nPlayer types:")
    print("1. Human")
    print("2. Computer")
    
    player1_type = get_player_type("Player 1 (X)")
    player2_type = get_player_type("Player 2 (O)")
    
    # Get computer difficulty if applicable
    player1_level = 1
    player2_level = 1
    
    if player1_type == "computer":
        player1_level = get_computer_level("Player 1")
    
    if player2_type == "computer":
        player2_level = get_computer_level("Player 2")
    
    # Start the game
    play_game(board, player1_type, player2_type, player1_level, player2_level)




# ---------------- MAIN ----------------
if __name__ == "__main__":
    menu()
