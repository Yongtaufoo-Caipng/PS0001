#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Oct 13 23:04:12 2025

@author: kennykhoo123
"""

# %%
def display_board(board):
    n = int(len(board) ** 0.5)  # This is to get the board side length, board is stored as one list, so I took the square root to get the number of rows/columns.”

    print("=" * (n * 4 + 1))      # Each cell takes up 4 characters (" X |"), and there is 1 extra border on the left.
                                         # So total width of the board border = n * 4 + 1.
    
    for i in range(n):
        row_str = "|"             #The left border      
        for j in range(n):         #Outer loop will be for rows and inner loop will be for columns
            symbol = " "           # Each cell can assumed to be blank first 
#Indexes in row 0: 0, 1, 2, 3, 4
#Indexes in row 1: 5, 6, 7, 8, 9
#Indexes in row 2: 10, 11, 12, 13, 14
#To get to row 2, you skip 2 full rows (2 × 5 = 10 items).
#Then, you move 3 steps into that row (add 3).
#thus, 10 + 3 = 13.

            if board[i*n + j] == 1:
                symbol = "X"       #defines X
            elif board[i*n + j] == 2:
                symbol = "O"       #Defines O
            row_str += f" {symbol} |"     #F string tells python
                                          #to replace anything inside {} with its actual value
        print(row_str)    # will print out / symbol /
        if i < n - 1:              #Dont print a line after last row
            print("|" + "---|" * n)
    
    print("=" * (n * 4 + 1))   #prints the bottom border, put + 1 to accoubt for left border, the formula is to count how many spaces
                               # is needed to form the ======= bottom border
    
    # Display index numbers for reference
    print("\nIndex positions:")
    for i in range(n):
        row_str = ""
        for j in range(n):
            row_str += f" {i*n + j:2d} "   #2d is to make sure the integers take up at least 2 spaces
        print(row_str)
    print()

import random
import os



def check_move(board, turn, index, push_from): #passed into the function as a parameter
    
    n = int(len(board) ** 0.5)  # len(board) gives the total number of elements in the list
    #len(board)= n x n hence n = sqaureroot (len(board))
    #n is how many cubes fit on one side of the square board
    
    # Check if the cube index is within the range 0 to n^2-1
    # index is which cube the player pick, is a number
    if index < 0 or index >= len(board):
        return False
    #if either one of the index is true the whole thing will return false 
    
    # Check if the cube is on the outer ring of the board

    row = index // n   # // is floor division get the integer only and to get the row number 
    col = index % n  # is to check for col number 
    if not (row == 0 or row == n-1 or col == 0 or col == n-1):
            #top edge   #bottom edge  #left egde  #right edge
            #T F F F = T , if not(T) = F , return F as condition is F 
            #F F F F = F ,  if not(F) = T , do not return F as condition is T
        return False
    
    # Check if the cube belongs to the player or is blank
    #!= not equal to, board[index] is the symbol at that point, means only X or O
    if board[index] != 0 and board[index] != turn: #turn is 1 or 2 
    # turn represents the current player's turn, the 0 means it's an empty square 
    # eg  if the board is not 0 and it is not the players turn then it will return false 
    # and is T if both are T, then can return F means game dont continue
        return False #invalid move 
    
    # Check if push direction is valid
    if push_from not in ['T', 'B', 'L', 'R']:
        return False
    
    # Check if we're not pushing from the same position
    if (push_from == 'T' and row == 0) or \
       (push_from == 'B' and row == n-1) or \
       (push_from == 'L' and col == 0) or \
       (push_from == 'R' and col == n-1):
        return False 
    #to check if we are trying to push from the same edge that we are already on 
    #eg at 0 cannot push from Top position anymore, so if any of this is true can return false  
    
    return True

def apply_move(board, turn, index, push_from):
   
    n = int(len(board) ** 0.5)  # len(board) gives total no. of cells(25), ** 0.5 takes the square root(5), int() converts it to an integer 
    new_board = board[:]
    new_board = list(board) # can modify new_board w/o changing original board
    
    row = index // n   # // is floor division get the integer only
    col = index % n
    
    if push_from == 'T':
        # shift column down from the top
        for r in range(row, 0, -1): # the loop counts downwards to prevent overwriting a value we still need to read
            new_board[r*n + col] = new_board[(r-1)*n + col] # destination index is r*n + col the cell at row r column col, source index is (r-1)*n + col the cell one row above the destination
            # destination index is r*n + col the cell at row r column col, source index is (r-1)*n + col the cell one row above the destination
            # 2D index formula r*n + c
            # definition of a downward shift for a 'T' push: destination (r, c) gets the value from one row above (r-1,c)
        new_board[col] = turn  # your piece (turn) is inserted at the top
    
    elif push_from == 'B':
        # shift column up from the bottom
        for r in range(row, n-1): # gives row, row+1, ..., n-2, loop goes upwards
            new_board[r*n + col] = new_board[(r+1)*n + col]
        new_board[(n-1)*n + col] = turn  # your piece is inserted at the bottom position
    
    elif push_from == 'L':
        # shift row right from the left, cells are shifted to the right
        for c in range(col, 0, -1): # loop counts right to left
            new_board[row*n + c] = new_board[row*n + (c-1)] # destination (row, c) gets the value from its left (row, c-1), right to left avoids overwriting data
        new_board[row*n] = turn  # your piece is inserted at the left position
    
    elif push_from == 'R':
        # shift row left from the right
        for c in range(col, n-1): # destination takes value from its right
            new_board[row*n + c] = new_board[row*n + (c+1)]
        new_board[row*n + (n-1)] = turn  # your piece is inserted at the right position
    
    return new_board
    
    # Check if the cube belongs to the player or is blank
    #!= not equal to ,i board[index] is the value at that point means only X or O
    if board[index] != 0 and board[index] != turn: # turn represents the current players turn
    #and is T if both are T , then can return F 
        return False #invalid move 
    
    # Check if push direction is valid
    if push_from not in ['T', 'B', 'L', 'R']:
        return False
    
    # Check if we're not pushing from the same position
    if (push_from == 'T' and row == 0) or \
       (push_from == 'B' and row == n-1) or \
       (push_from == 'L' and col == 0) or \
       (push_from == 'R' and col == n-1):
        return False #either one of the abv are true then can return as false
    
    return True

def check_victory(board, who_played):
    n = int(len(board) ** 0.5)
    player1_win = False
    player2_win = False
    #start with both false as none have won
    #start with false if not if the bottom checking part have error, players will win without actually winning
    #check rows
    for i in range(n): #check each row 
        row_win1 = True 
        row_win2 = True
        #asumming both player might win at this row
        for j in range(n):
            if board[i*n + j] != 1:
            #for this row (i) and at this column (j) does it have 1 or 2 
            #check at which specific square have either 1 or 2
            #if at that i row does not have all 1 then player 1 did not win
                row_win1 = False
            #repeat the same for player 2
            if board[i*n + j] != 2:
                row_win2 = False
        #if the whole row have 1 then player 1 wins, same for player 2
        if row_win1:
            player1_win = True
        if row_win2:
            player2_win = True
        #loop will continue for all rows
    
    #check columns
    #do the same for columns
    for j in range(n):
        col_win1 = True
        col_win2 = True
        for i in range(n):
            if board[i*n + j] != 1:
                col_win1 = False
            if board[i*n + j] != 2:
                col_win2 = False
        
        if col_win1:
            player1_win = True
        if col_win2:
            player2_win = True
        #loop continues for all column 
    
    #check diagonal (top left to bottom right)
    #do the same for first diagonal 
    diag1_win1 = True
    diag1_win2 = True
    for i in range(n):
        if board[i*n + i] != 1:
        #checking for squares at 0,6,12,18,24 so use [i*n + i]
            diag1_win1 = False
        if board[i*n + i] != 2:
            diag1_win2 = False
    
    if diag1_win1:
        player1_win = True
    if diag1_win2:
        player2_win = True
    
    #check diagonal (top right to bottom left)
    #do the same for second diagonal
    diag2_win1 = True
    diag2_win2 = True
    for i in range(n):
        if board[i*n + (n-1-i)] != 1:
        #checking for squares at 4,8,12,16,20 so use [i*n +(n-1-i)]
            diag2_win1 = False
        if board[i*n + (n-1-i)] != 2:
            diag2_win2 = False
    
    if diag2_win1:
        player1_win = True
    if diag2_win2:
        player2_win = True
    
    #determine winner
    if player1_win and player2_win:
        return 3 - who_played
    # - who played so if player 1 played then 3-1 so player 2 wins
    elif player1_win:
        return 1
    #return 1 = player 1 win
    elif player2_win:
        return 2
    #return 2 = player 2 win
    else:
        return 0
    # return 0 = no winners 

def generate_valid_moves(board, turn):
    """Generate all valid moves for a player."""
    #from the board
    n = int(len(board) ** 0.5)
    #create a empty list to put all legal moves
    valid_moves = []
    #look at every square in the board
    for index in range(len(board)):
        #need to check in all 4 directions
        for push_from in ['T', 'B', 'L', 'R']:
            if check_move(board, turn, index, push_from):
                valid_moves.append((index, push_from))
                #check moves first. if true then add to the board 
    
    return valid_moves


def computer_move(board, turn, level):# current board state, turn, current player's level and the difficulty level

    n = int(len(board) ** 0.5)  # Board size, len(board)= n x n hence n = sqaureroot (len(board))
    valid_moves = [] #list and initialisation
   
    # Generate all possible valid moves
    for index in range(len(board)): #in range of the board size
    #len(board) gives the number of cubes on the board 
    # 5x5 board len(board) = 25
        for push_from in ['T', 'B', 'L', 'R']: # tries all 4 directions, push from is the variable 
            if check_move(board, turn, index, push_from): #parameters 
            #( to check if its a valid move for the player to push the cube number(index) from direction (push_from))
 #(board: current game board , turn: which players turn: index: the code we are checking, push_from: the direction we are checking)
                valid_moves.append((index, push_from)) # is a list that stores all the valid moves found so far
                #append is to add an item to the end of the list 
                #add this valid move ( index and direction) to the list of valid moves
    
    if not valid_moves: # not valid means the list is empty  no possible moves to make 
        return 0, 'T'
    # 0 is the first cube on the board index 0 
    # T push from top 
    # if computer has no valid move, default move is cube 0 from top
    if level == 1:
        # Level 1: Random move
        return random.choice(valid_moves) 
    # chooses one random item from the list, each item is a tuple (index, push_from)
    # js to pick a random valid move to play
    
    elif level == 2:
        # Level 2: Check for winning moves and avoid opponent's winning moves
        # Check for immediate win
        for index, push_from in valid_moves: # for a loop that goes through every possible valid move
        # index is the cube position and push_from is the direction
            test_board = apply_move(board, turn, index, push_from)
            #test_board stores the temporary board to test what happened after the move is played
            if check_victory(test_board, turn) == turn: # to check who won, if it equals means the current player won
                return index, push_from # if the abv move can win will be returned 
        
        # Check if opponent can win next move and block it
        opponent = 3 - turn # figure out who the opponent is, turn is 1 or 2
        for index, push_from in valid_moves: # go through every possible valid moves
            test_board = apply_move(board, turn, index, push_from)
            # js a simulation board
            
            # Check all opponent moves after this move
            opponent_can_win = False # assume that opponent cannot win/ no winning move
            for opp_index, opp_push in generate_valid_moves(test_board, opponent): 
                # a list of all possible moves the opponent can make on the test board
                opp_test_board = apply_move(test_board, opponent, opp_index, opp_push) 
                #simulates what it will look like if the opponent make the move 
                if check_victory(opp_test_board, opponent) == opponent: #check if opponent wins
                    opponent_can_win = True
                    break # simce opponent can win through that move stop as its a bad move 
            
            if not opponent_can_win:# opponent cannot win
                return index, push_from
            # safe to play 
        
        # If no strategic move found, return random move
        return random.choice(valid_moves)

def play_game(board, player1_type, player2_type, player1_level, player2_level):
    #main game loop, defines a function named play_game that will run the whole match loop.
    #difficulty no. for the comp
    current_player = 1 #sets who moves first
    game_over = False #when False, game is still running. It is set to True when someone wins or quits which stops the loops.
    
    while not game_over:
        display_board(board)
        #start a while loop that keeps running until the game is over
        #not game_over is True when the game is still running
        #call a function to print the current board so that the plaer can see it before making a move
        
        if current_player == 1: #branch based on whose turn it is
            player_type = player1_type
            level = player1_level #difficulty for computer can be ignored if p1 is human
        else:
            player_type = player2_type
            level = player2_level
        
        print(f"Player {current_player}'s turn ({'X' if current_player == 1 else 'O'})")
        #prints whose turn it is
        #{'X' if current player == 1 else 'O'} is a conditional expression that choose 'X' for p1, 'O' for p2
        
        if player_type == "human": #checks if the current player is human
            index, push_from = get_human_move(board, current_player) #calls helper to validate input
        else: 
            print("Computer is thinking...") #print status message
            index, push_from = computer_move(board, current_player, level)
            print(f"Computer plays: index {index}, push from {push_from}")
