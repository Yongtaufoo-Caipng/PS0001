#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Oct 13 23:04:12 2025

@author: kennykhoo123
"""

# %%
def display_board(board):
    n = int(len(board) ** 0.5)  # This is to get the board side length, board is stored as one list, so I took the square root to get the number of rows/columns.”

    print("=" * (n * 4 + 1))      # Each cell takes up 4 characters (" X |"), and there is 1 extra border on the left.
                                         # So total width of the board border = n * 4 + 1.
    
    for i in range(n):
        row_str = "|"             #The left border      
        for j in range(n):         #Outer loop will be for rows and inner loop will be for columns
            symbol = " "           # Each cell can assumed to be blank first 
#Indexes in row 0: 0, 1, 2, 3, 4
#Indexes in row 1: 5, 6, 7, 8, 9
#Indexes in row 2: 10, 11, 12, 13, 14
#To get to row 2, you skip 2 full rows (2 × 5 = 10 items).
#Then, you move 3 steps into that row (add 3).
#thus, 10 + 3 = 13.

            if board[i*n + j] == 1:
                symbol = "X"       #defines X
            elif board[i*n + j] == 2:
                symbol = "O"       #Defines O
            row_str += f" {symbol} |"     #F string tells python
                                          #to replace anything inside {} with its actual value
        print(row_str)    # will print out / symbol /
        if i < n - 1:              #Dont print a line after last row
            print("|" + "---|" * n)
    
    print("=" * (n * 4 + 1))   #prints the bottom border, put + 1 to accoubt for left border, the formula is to count how many spaces
                               # is needed to form the ======= bottom border
    
    # Display index numbers for reference
    print("\nIndex positions:")
    for i in range(n):
        row_str = ""
        for j in range(n):
            row_str += f" {i*n + j:2d} "   #2d is to make sure the integers take up at least 2 spaces
        print(row_str)
    print()

import random
import os

def check_move(board, turn, index, push_from): #passed into the function as a parameter
    
    n = int(len(board) ** 0.5)  # len(board) gives the total number of elements in the list
    #len(board)= n x n hence n = sqaureroot (len(board))
    #n is how many cubes fit on one side of the square board
    
    # Check if the cube index is within the range 0 to n^2-1
    # index is which cube the player pick is a number
    if index < 0 or index >= len(board):
        return False
    #if either one of the index is true the whole thing will print false 
    
    # Check if the cube is on the outer ring of the board

    row = index // n   # // is floor division get the integer only and to get the row number 
    col = index % n  # is to check for col number 
    if not (row == 0 or row == n-1 or col == 0 or col == n-1):
            #top edge   #bottom edge  #left egde  #right edge
            #T F F F = T , if not(T) = F , return F as condition is F 
            #F F F F = F ,  if not(F) = T , do not return F as condition is T
        return False

def apply_move(board, turn, index, push_from):
   
    n = int(len(board) ** 0.5)  # len(board) gives total no. of cells(25), ** 0.5 takes the square root(5), int() converts it to an integer 
    new_board = board[:]
    new_board = list(board) # can modify new_board w/o changing original board
    
    row = index // n   # // is floor division get the integer only
    col = index % n
    
    if push_from == 'T':
        # shift column down from the top
        for r in range(row, 0, -1): # the loop counts downwards to prevent overwriting a value we still need to read
            new_board[r*n + col] = new_board[(r-1)*n + col] # destination index is r*n + col the cell at row r column col, source index is (r-1)*n + col the cell one row above the destination
            # destination index is r*n + col the cell at row r column col, source index is (r-1)*n + col the cell one row above the destination
            # 2D index formula r*n + c
            # definition of a downward shift for a 'T' push: destination (r, c) gets the value from one row above (r-1,c)
        new_board[col] = turn  # your piece (turn) is inserted at the top
    
    elif push_from == 'B':
        # shift column up from the bottom
        for r in range(row, n-1): # gives row, row+1, ..., n-2, loop goes upwards
            new_board[r*n + col] = new_board[(r+1)*n + col]
        new_board[(n-1)*n + col] = turn  # your piece is inserted at the bottom position
    
    elif push_from == 'L':
        # shift row right from the left, cells are shifted to the right
        for c in range(col, 0, -1): # loop counts right to left
            new_board[row*n + c] = new_board[row*n + (c-1)] # destination (row, c) gets the value from its left (row, c-1), right to left avoids overwriting data
        new_board[row*n] = turn  # your piece is inserted at the left position
    
    elif push_from == 'R':
        # shift row left from the right
        for c in range(col, n-1): # destination takes value from its right
            new_board[row*n + c] = new_board[row*n + (c+1)]
        new_board[row*n + (n-1)] = turn  # your piece is inserted at the right position
    
    return new_board
    
    # Check if the cube belongs to the player or is blank
    #!= not equal to ,i board[index] is the value at that point means only X or O
    if board[index] != 0 and board[index] != turn: # turn represents the current players turn
    #and is T if both are T , then can return F 
        return False #invalid move 
    
    # Check if push direction is valid
    if push_from not in ['T', 'B', 'L', 'R']:
        return False
    
    # Check if we're not pushing from the same position
    if (push_from == 'T' and row == 0) or \
       (push_from == 'B' and row == n-1) or \
       (push_from == 'L' and col == 0) or \
       (push_from == 'R' and col == n-1):
        return False #either one of the abv are true then can return as false
    
    return True

def check_victory(board, who_played):
    n = int(len(board) ** 0.5)
    player1_win = False
    player2_win = False
    #start with both false as none have won
    #start with false if not if the bottom checking part have error, players will win without actually winning
    #check rows
    for i in range(n): #check each row 
        row_win1 = True 
        row_win2 = True
        #asumming both player might win at this row
        for j in range(n):
            if board[i*n + j] != 1:
            #for this row (i) and at this column (j) does it have 1 or 2 
            #check at which specific square have either 1 or 2
            #if at that i row does not have all 1 then player 1 did not win
                row_win1 = False
            #repeat the same for player 2
            if board[i*n + j] != 2:
                row_win2 = False
        #if the whole row have 1 then player 1 wins, same for player 2
        if row_win1:
            player1_win = True
        if row_win2:
            player2_win = True
        #loop will continue for all rows
    
    #check columns
    #do the same for columns
    for j in range(n):
        col_win1 = True
        col_win2 = True
        for i in range(n):
            if board[i*n + j] != 1:
                col_win1 = False
            if board[i*n + j] != 2:
                col_win2 = False
        
        if col_win1:
            player1_win = True
        if col_win2:
            player2_win = True
        #loop continues for all column 
