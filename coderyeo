import random
import os

def check_move(board, turn, index, push_from): #passed into the function as a parameter
    
    n = int(len(board) ** 0.5)  # len(board) gives the total number of elements in the list
    #len(board)= n x n hence n = sqaureroot (len(board))
    #n is how many cubes fit on one side of the square board
    
    # Check if the cube index is within the range 0 to n^2-1
    # index is which cube the player pick is a number
    if index < 0 or index >= len(board):
        return False
    #if either one of the index is true the whole thing will print false 
    
    # Check if the cube is on the outer ring of the board

    row = index // n   # // is floor division get the integer only and to get the row number 
    col = index % n  # is to check for col number 
    if not (row == 0 or row == n-1 or col == 0 or col == n-1):
            #top edge   #bottom edge  #left egde  #right edge
            #T F F F = T , if not(T) = F , return F as condition is F 
            #F F F F = F ,  if not(F) = T , do not return F as condition is T
        return False
    
    # Check if the cube belongs to the player or is blank
    #!= not equal to ,i board[index] is the value at that point means only X or O
    if board[index] != 0 and board[index] != turn: # turn represents the current players turn
    #and is T if both are T , then can return F 
        return False #invalid move 
    
    # Check if push direction is valid
    if push_from not in ['T', 'B', 'L', 'R']:
        return False
    
    # Check if we're not pushing from the same position
    if (push_from == 'T' and row == 0) or \
       (push_from == 'B' and row == n-1) or \
       (push_from == 'L' and col == 0) or \
       (push_from == 'R' and col == n-1):
        return False #either one of the abv are true then can return as false
    
    return True




def computer_move(board, turn, level):# current board state, turn, current players level and the difficulty level

    n = int(len(board) ** 0.5)  # Board size , len(board)= n x n hence n = sqaureroot (len(board))
    valid_moves = [] #list and initialisation
    
    elif player2_win:
        return 2
    else:
        return 0
    # Generate all possible valid moves
    for position in range(len(board)): #in range of the board size
    #len(board) gives the number of cubes on the board 
    # 5x5 board len(board) = 25
        for push_from in ['T', 'B', 'L', 'R']: # tries all 4 directions, push from is the variable 
            if check_move(board, turn, index, push_from): #parameters 
            #( to check if its a valid move for the player to push the cube number( index) from direction(push_from))
 #(board: current game board , turn: which players turn: index: the code we are checking, push_from: the direction we are checking)
                valid_moves.append((index, push_from)) # is a list that stores all the valid moves found so far
                #append is to add an item to the end of the list 
                #add this valid move ( index and direction) to the list of valid moves
    
    if not valid_moves: # not valid means the list is empty  no possible moves to make 
        return 0, 'T'
    # 0 is the first cube on the board index 0 
    # T push from top 
    # if computer has no valid move, default move is cube 0 from top
    if level == 1:
        # Level 1: Random move
        return random.choice(valid_moves) 
    # chooses one random item from the list, each item is a tuple ( index, push_from)
    # js to pick a random valid move to play
    
    elif level == 2:
        # Level 2: Check for winning moves and avoid opponent's winning moves
        # Check for immediate win
        for index, push_from in valid_moves: # for a loop that goes through every possible valid move
        # index is the cube position and push_from uis the direction
            test_board = apply_move(board, turn, index, push_from)
            #test_board stores the temporary board to test what happend after the move is played
            if check_victory(test_board, turn) == turn: # to check who won if it equals means the current player won
                return index, push_from # if the abv move can win will be returned
        
        # Check if opponent can win next move and block it
        opponent = 3 - turn # figure out who the opponent is, turn is 1 or 2
        for index, push_from in valid_moves: # go through every possible valid moves
            test_board = apply_move(board, turn, index, push_from)
            # js a simulation board
            
            # Check all opponent moves after this move
            opponent_can_win = False # assume that opponent cannot win/ no winning move
            for opp_index, opp_push in generate_valid_moves(test_board, opponent): 
                # a list of all possible moves the opponent can make on the test board
                opp_test_board = apply_move(test_board, opponent, opp_index, opp_push) 
                #simulates what it will look like if the opponent make the move 
                if check_victory(opp_test_board, opponent) == opponent: #check if opponent wins
                    opponent_can_win = True
                    break # simce opponent can win through that move stop as its a bad move 
            
            if not opponent_can_win:# opponent cannot win
                return index, push_from
            # safe to play 
        
        # If no strategic move found, return random move
        return random.choice(valid_moves)
